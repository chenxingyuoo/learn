<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>

<body>


1.演员表
<br/>
首先介绍将要参与到对程序 var a = 2; 进行处理的过程中的演员们，这样才能理解接下来
将要听到的对话。
<br/>
• 引擎
  从头到尾负责整个 JavaScript 程序的编译及执行过程。
• 编译器
  引擎的好朋友之一，负责语法分析及代码生成等脏活累活(详见前一节的内容)。
• 作用域
  引擎的另一位好朋友，负责收集并维护由所有声明的标识符(变量)组成的一系列查 询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。

<br/>
为了能够完全理解 JavaScript 的工作原理，你需要开始像引擎(和它的朋友们)一样思考， 从它们的角度提出问题，并从它们的角度回答这些问题。

<br/>

2.对话

当你看见 var a = 2; 这段程序时，很可能认为这是一句声明。但我们的新朋友引擎却不这
么看。事实上，引擎认为这里有两个完全不同的声明，一个由编译器在编译时处理，另一个则由引擎在运行时处理。

下面我们将 var a = 2; 分解，看看引擎和它的朋友们是如何协同工作的。

编译器首先会将这段程序分解成词法单元，然后将词法单元解析成一个树结构。但是当编 译器开始进行代码生成时，它对这段程序的处理方式会和预期的有所不同。

可以合理地假设编译器所产生的代码能够用下面的伪代码进行概括:“为一个变量分配内 存，将其命名为 a，然后将值 2 保存进这个变量。”然而，这并不完全正确。

事实上编译器会进行如下处理。

    1. 遇到 var a，编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的 集合中。
    如果是，编译器会忽略该声明，继续进行编译;否则它会要求作用域在当前作 用域的集合中声明一个新的变量，并命名为 a。

    2. 接下来编译器会为引擎生成运行时所需的代码，这些代码被用来处理 a = 2 这个赋值 操作。引擎运行时会首先询问作用域，
    在当前的作用域集合中是否存在一个叫作 a 的 变量。如果是，引擎就会使用这个变量;如果否，引擎会继续查找该变量(查看 1.3 节)。

如果引擎最终找到了 a 变量，就会将 2 赋值给它。否则引擎就会举手示意并抛出一个异 常!

总结:变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量(如 果之前没有声明过)，然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对 它赋值。


3.编译器有话说

为了进一步理解，我们需要多介绍一点编译器的术语。

编译器在编译过程的第二步中生成了代码，引擎执行它时，会通过查找变量 a 来判断它是 否已声明过。
查找的过程由作用域进行协助，但是引擎执行怎样的查找，会影响最终的查 找结果。

在我们的例子中，引擎会为变量 a 进行 LHS 查询。另外一个查找的类型叫作 RHS。

我打赌你一定能猜到“L”和“R”的含义，它们分别代表左侧和右侧。

什么东西的左侧和右侧?是一个赋值操作的左侧和右侧。 换句话说，当变量出现在赋值操作的左侧时进行 LHS 查询，出现在右侧时进行 RHS 查询。

讲得更准确一点，RHS 查询与简单地查找某个变量的值别无二致，而 LHS 查询则是试图 找到变量的容器本身，从而可以对其赋值。
从这个角度说，RHS 并不是真正意义上的“赋 值操作的右侧”，更准确地说是“非左侧”。


你可以将 RHS 理解成 retrieve his source value(取到它的源值)，这意味着“得到某某的 值”。

让我们继续深入研究。

考虑以下代码:
   console.log( a );

其中对 a 的引用是一个 RHS 引用，因为这里 a 并没有赋予任何值。相应地，需要查找并取
得 a 的值，这样才能将值传递给 console.log(..)。

相比之下，例如:
    a = 2;

这里对 a 的引用则是 LHS 引用，因为实际上我们并不关心当前的值是什么，只是想要为
= 2 这个赋值操作找到一个目标。

****
LHS 和 RHS 的含义是“赋值操作的左侧或右侧”并不一定意味着就是“= 赋值操作符的左侧或右侧”。
赋值操作还有其他几种形式，因此在概念上最 好将其理解为“赋值操作的目标是谁(LHS)”以及“谁是赋值操作的源头(RHS)”


考虑下面的程序，其中既有 LHS 也有 RHS 引用:

    function foo(a) {
      console.log( a ); // 2
    }
    foo( 2 );

最后一行 foo(..) 函数的调用需要对 foo 进行 RHS 引用，意味着“去找到 foo 的值，并把 它给我”。
并且 (..) 意味着 foo 的值需要被执行，因此它最好真的是一个函数类型的值!

这里还有一个容易被忽略却非常重要的细节。

代码中隐式的 a=2 操作可能很容易被你忽略掉。这个操作发生在 2 被当作参数传递给 foo(..) 函数时，2 会被分配给参数 a。
为了给参数 a(隐式地)分配值，需要进行一次 LHS 查询。

这里还有对 a 进行的 RHS 引用，并且将得到的值传给了 console.log(..)。console. log(..) 本身也需要一个引用才能执行，
因此会对 console 对象进行 RHS 查询，并且检查 得到的值中是否有一个叫作 log 的方法。


最后，在概念上可以理解为在 LHS 和 RHS 之间通过对值 2 进行交互来将其传递进 log(..) (通过变量 a 的 RHS 查询)。
假设在 log(..) 函数的原生实现中它可以接受参数，在将 2 赋值给其中第一个(也许叫作 arg1)参数之前，这个参数需要进行 LHS 引用查询。


你可能会倾向于将函数声明 function foo(a) {... 概念化为普通的变量声明 和赋值，比如 var foo、foo = function(a) {...。如果这样理解的话，
这 个函数声明将需要进行 LHS 查询。 然而还有一个重要的细微差别，编译器可以在代码生成的同时处理声明和值 的定义，比如在引擎执行代码时，
并不会有线程专门用来将一个函数值“分 配给”foo。因此，将函数声明理解成前面讨论的 LHS 查询和赋值的形式并 不合适。


4.引擎和作用域的对话

    引擎:我说作用域，我需要为 foo 进行 RHS 引用。你见过它吗?
    作用域:别说，我还真见过，编译器那小子刚刚声明了它。它是一个函数，给你。
    引擎:哥们太够意思了!好吧，我来执行一下 foo。
    引擎:作用域，还有个事儿。我需要为 a 进行 LHS 引用，这个你见过吗?
    作用域:这个也见过，编译器最近把它声名为 foo 的一个形式参数了，拿去吧。
    引擎:大恩不言谢，你总是这么棒。现在我要把 2 赋值给 a。 引擎:哥们，不好意思又来打扰你。我要为 console 进行 RHS 引用，你见过它吗?
    作用域:咱俩谁跟谁啊，再说我就是干这个。这个我也有，console 是个内置对象。 给你。
    引擎:么么哒。我得看看这里面是不是有 log(..)。太好了，找到了，是一个函数。
    引擎:哥们，能帮我再找一下对 a 的 RHS 引用吗?虽然我记得它，但想再确认一次。
    作用域:放心吧，这个变量没有变动过，拿走，不谢。
    引擎:真棒。我来把 a 的值，也就是 2，传递进 log(..)。


5.小测验

检验一下到目前的理解程度。把自己当作引擎，并同作用域进行一次“对话”:

function foo(a) {
    var b = a;
    return a + b;
}
var c = foo( 2 );

1. 找到其中所有的LHS查询。(这里有3处!)
2. 找到其中所有的RHS查询。(这里有4处!)

LHS :
c = ..;、a = 2(隐式变量分配)、b = ..

RHS:
foo(2..、= a;、a ..、.. b



6.作用域嵌套

我们说过，作用域是根据名称查找变量的一套规则。实际情况中，通常需要同时顾及几个
作用域。

当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。因此，在当前作用 域中无法找到某个变量时，
引擎就会在外层嵌套的作用域中继续查找，直到找到该变量， 或抵达最外层的作用域(也就是全局作用域)为止

考虑以下代码:

function foo(a) {
   console.log( a + b );
}
var b = 2;
foo( 2 ); // 4

对 b 进行的 RHS 引用无法在函数 foo 内部完成，但可以在上一级作用域(在这个例子中就 是全局作用域)中完成

因此，回顾一下引擎和作用域之间的对话，会进一步听到:

引擎:foo 的作用域兄弟，你见过 b 吗?我需要对它进行 RHS 引用。
作用域:听都没听过，走开。
引擎:foo 的上级作用域兄弟，咦?有眼不识泰山，原来你是全局作用域大哥，太好了。你见过 b 吗?我需要对它进行 RHS 引用。
作用域:当然了，给你吧。

遍历嵌套作用域链的规则很简单:引擎从当前的执行作用域开始查找变量，如果找不到， 就向上一级继续查找。
当抵达最外层的全局作用域时，无论找到还是没找到，查找过程都 会停止。

建筑可以代表程序中的嵌套作用域链。第一层楼代表当前的执行作用域，也就是你所处的 位置。建筑的顶层代表全局作用域。

LHS 和 RHS 引用都会在当前楼层进行查找，如果没有找到，就会坐电梯前往上一层楼， 如果还是没有找到就继续向上，以此类推。
一旦抵达顶层(全局作用域)，可能找到了你 所需的变量，也可能没找到，但无论如何查找过程都将停止。

7.异常

为什么区分 LHS 和 RHS 是一件重要的事情?

因为在变量还没有声明(在任何作用域中都无法找到该变量)的情况下，这两种查询的行 为是不一样的。

考虑如下代码:

    function foo(a) {
        console.log( a + b ); b = a;
    }
    foo( 2 );

ReferenceError 同作用域判别失败相关，而 TypeError 则代表作用域判别成功了，但是对 结果的操作是非法或不合理的。
</body>
</html>