<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>

<body>


<script>

    //与命令式不同，声明式意味着我们要写表达式，而不是一步一步的指示。

    //以 SQL 为例，它就没有“先做这个，再做那个”的命令，有的只是一个指明我们想要从数据库取什么数据的表达式。
    // 至于如何取数据则是由它自己决定的。以后数据库升级也好，SQL 引擎优化也好，根本不需要更改查询语句。
    // 这是因为，有多种方式解析一个表达式并得到相同的结果。

    // 示例数据
    var cars = [
        {name: "Ferrari FF", horsepower: 660, dollar_value: 700000, in_stock: true},
        {name: "Spyker C12 Zagato", horsepower: 650, dollar_value: 648000, in_stock: false},
        {name: "Jaguar XKR-S", horsepower: 550, dollar_value: 132000, in_stock: false},
        {name: "Audi R8", horsepower: 525, dollar_value: 114200, in_stock: false},
        {name: "Aston Martin One-77", horsepower: 750, dollar_value: 1850000, in_stock: true},
        {name: "Pagani Huayra", horsepower: 700, dollar_value: 1300000, in_stock: false}
    ];

    // 命令式
    console.time('命令式');
    var dollar_value = [];
    for (var i = 0; i < cars.length; i++) {
        dollar_value.push(cars[i].dollar_value);
    }
    console.timeEnd('命令式');

    // 声明式
    console.time('声明式');
    var dollar_values = cars.map(function(car){ return car.dollar_value; });
    console.timeEnd('声明式');
    console.log(dollar_values);


    // 命令式
    var authenticate = function(form) {
        var user = toUser(form)
        return logIn(user);
    };


    //函数组合
    var compose = function(f,g) {
        return function(x) {
            return f(g(x));
        };
    };

    // 声明式
    var authenticate = compose(logIn, toUser);

    //虽然命令式的版本并不一定就是错的，但还是硬编码了那种一步接一步的执行方式。
    // 而 compose 表达式只是简单地指出了这样一个事实：用户验证是 toUser 和 logIn 两个行为的组合。
    // 这再次说明，声明式为潜在的代码更新提供了支持，使得我们的应用代码成为了一种高级规范（high level specification）。


    //因为声明式代码不指定执行顺序，所以它天然地适合进行并行运算。
    // 它与纯函数一起解释了为何函数式编程是未来并行计算的一个不错选择——我们真的不需要做什么就能实现一个并行／并发系统。


</script>

</body>
</html>